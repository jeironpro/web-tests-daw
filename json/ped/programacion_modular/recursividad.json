[
    {
        "pregunta": "¿Qué es la recursividad?",
        "opciones": [
            "Una repetición",
            "Un bucle while",
            "Un error",
            "Una técnica donde una función se llama a sí misma para resolver un problema"
        ],
        "respuesta": 3,
        "explicacion": "Divide el problema en subproblemas más pequeños."
    },
    {
        "pregunta": "¿Qué es el caso base?",
        "opciones": [
            "El error",
            "El inicio",
            "La condición que detiene la recursión (no se llama a sí misma)",
            "La base de datos"
        ],
        "respuesta": 2,
        "explicacion": "Sin él, Stack Overflow."
    },
    {
        "pregunta": "¿Qué es el caso recursivo?",
        "opciones": [
            "La parte donde la función se llama a sí misma con un problema más pequeño",
            "El error",
            "El bucle",
            "El final"
        ],
        "respuesta": 0,
        "explicacion": "Acerca el problema al caso base."
    },
    {
        "pregunta": "¿Qué error ocurre si falta el caso base?",
        "opciones": [
            "Syntax Error",
            "Stack Overflow (Desbordamiento de pila)",
            "Null Pointer",
            "Memory Leak"
        ],
        "respuesta": 1,
        "explicacion": "Recursión infinita."
    },
    {
        "pregunta": "¿Qué es el factorial de n (n!)?",
        "opciones": [
            "Una división",
            "Una suma",
            "Ejemplo clásico de recursión: n * factorial(n-1)",
            "Una resta"
        ],
        "respuesta": 2,
        "explicacion": "5! = 5 * 4 * 3 * 2 * 1."
    },
    {
        "pregunta": "¿Qué es la sucesión de Fibonacci?",
        "opciones": [
            "fib(n) = fib(n-1) + fib(n-2)",
            "Un array",
            "Una lista",
            "Una suma"
        ],
        "respuesta": 0,
        "explicacion": "Ineficiente si se hace recursivo ingenuo (O(2^n))."
    },
    {
        "pregunta": "¿Qué es la recursión de cola (Tail Recursion)?",
        "opciones": [
            "Recursión mala",
            "Recursión al principio",
            "Cuando la llamada recursiva es la última acción de la función (permite optimización)",
            "Recursión lenta"
        ],
        "respuesta": 2,
        "explicacion": "El compilador puede convertirla en un bucle."
    },
    {
        "pregunta": "¿Qué ventaja tiene la iteración (bucles) sobre la recursión?",
        "opciones": [
            "Es más corta",
            "Es más fácil",
            "Suele consumir menos memoria (no llena el stack) y ser más rápida",
            "Es más elegante"
        ],
        "respuesta": 2,
        "explicacion": "Eficiencia vs Legibilidad."
    },
    {
        "pregunta": "¿Qué ventaja tiene la recursión?",
        "opciones": [
            "Usa menos memoria",
            "Es obligatoria",
            "Soluciones más elegantes y simples para problemas jerárquicos (árboles, grafos)",
            "Es más rápida"
        ],
        "respuesta": 2,
        "explicacion": "Recorrer directorios, XML, etc."
    },
    {
        "pregunta": "¿Qué es la recursión indirecta?",
        "opciones": [
            "A llama a B",
            "Nadie llama a nadie",
            "A se llama a A",
            "Función A llama a B, y B llama a A"
        ],
        "respuesta": 3,
        "explicacion": "Ciclo de llamadas."
    },
    {
        "pregunta": "¿Qué es el 'Backtracking' (Vuelta atrás)?",
        "opciones": [
            "Borrar",
            "Ir hacia atrás",
            "Algoritmo recursivo que prueba caminos y retrocede si no encuentra solución (ej. laberinto)",
            "Copiar"
        ],
        "respuesta": 2,
        "explicacion": "Fuerza bruta inteligente."
    },
    {
        "pregunta": "¿Qué es la memoización?",
        "opciones": [
            "Guardar resultados de llamadas recursivas previas para no recalcularlos (optimización)",
            "Borrar",
            "Memorizar",
            "Olvidar"
        ],
        "respuesta": 0,
        "explicacion": "Hace Fibonacci recursivo eficiente (O(n))."
    },
    {
        "pregunta": "¿Qué estructura de datos usa el sistema para gestionar la recursión?",
        "opciones": [
            "Árbol",
            "Grafo",
            "Cola (Queue)",
            "Pila (Stack)"
        ],
        "respuesta": 3,
        "explicacion": "LIFO (Last In First Out)."
    },
    {
        "pregunta": "¿Qué es un fractal?",
        "opciones": [
            "Un número",
            "Un error",
            "Objeto geométrico cuya estructura se repite a diferentes escalas (generado recursivamente)",
            "Un dibujo"
        ],
        "respuesta": 2,
        "explicacion": "Triángulo de Sierpinski."
    },
    {
        "pregunta": "¿Cómo se convierte un algoritmo recursivo a iterativo?",
        "opciones": [
            "No se puede",
            "Usando una pila explícita y un bucle",
            "Borrando el código",
            "Cambiando el nombre"
        ],
        "respuesta": 1,
        "explicacion": "Siempre es posible."
    },
    {
        "pregunta": "¿Qué es las Torres de Hanoi?",
        "opciones": [
            "Un juego de cartas",
            "Una ciudad",
            "Un edificio",
            "Problema matemático clásico resuelto elegantemente con recursión"
        ],
        "respuesta": 3,
        "explicacion": "Mover discos entre postes."
    },
    {
        "pregunta": "¿Qué es la profundidad de recursión?",
        "opciones": [
            "El número máximo de llamadas anidadas activas al mismo tiempo",
            "El tiempo",
            "La dificultad",
            "El tamaño del archivo"
        ],
        "respuesta": 0,
        "explicacion": "Limitada por el tamaño del stack."
    },
    {
        "pregunta": "¿Qué es un algoritmo 'Divide y Vencerás'?",
        "opciones": [
            "Pelear",
            "Perder",
            "Dividir el problema en subproblemas, resolverlos recursivamente y combinar resultados (MergeSort)",
            "Ganar"
        ],
        "respuesta": 2,
        "explicacion": "Estrategia eficiente."
    },
    {
        "pregunta": "¿Cuándo NO usar recursión?",
        "opciones": [
            "Nunca",
            "Siempre",
            "En matemáticas",
            "Cuando la profundidad es muy grande o el rendimiento es crítico"
        ],
        "respuesta": 3,
        "explicacion": "Riesgo de crash."
    },
    {
        "pregunta": "¿Qué es una función mutuamente recursiva?",
        "opciones": [
            "A->B",
            "B->B",
            "Igual que recursión indirecta (A->B->A)",
            "A->A"
        ],
        "respuesta": 2,
        "explicacion": "Par/Impar."
    }
]